## RFC: Ideas For A Screenplay

When one first thinks of the internet, one thinks of networks and networks upon networks. In particular, you are probably thinking of your device, in one network, connected to another device, in another network. But, once you start to study the internet, you see that it is a _layered communication_ network, where each layer is governed by a communication _protocol_. In this piece, I'll try to explain this in a bit more detail.

Let's start by giving those devices we just mentioned some names; let's call one of them "Your Device", and let's say the other one is named "SiteGround's Device". Although these are essential players in our show, they are merely _hosts_ to the show's stars. Your Device and SiteGround's Device contain the co-stars that we'll know and love by the names "Client" and "Server". These are _applications_ on Your Device and SiteGround's Device, respectively. Client is a web browser. So, if you like, you can mentally give Client another name like "Chrome", but I'll continue to refer to what you are calling "Chrome" as "Client".

#### Act I

Okay, dear reader, let's set the scene. You open up Client on Your Device, you type "https://www.siteground.com/", and you hit enter. You do this hoping that Client will take you to SiteGround's homepage because you want to build a website. But cool your jets. There's a lot that happens in that split second before Client sends a request that has anything remotely to do with your intentions. Suppose Client and Server have never met. How do they find each other?

All internet communication must occur under the _Internet Protocol_ (IP), which is to say Client must know Server's _IP address_. Somehow Client has to get from knowing the "www.siteground.com" _hostname_ to the IP address of SiteGround's Device. If you like, you can think of "www.siteground.com" and the corresponding IP address as aliases for SiteGround's Device. Maybe this is a Hitchcockian spy thriller! In any case, Client has to communicate with the _Domain Name System_ (DNS) before it ever gets to talk to Server. Moreover, Client most likely communicates with applications on your _Internet Service Provider_'s (ISP's) devices before it ever communicates with the DNS! However, because such _connections_ are very similar to the one I will describe concerning Client and Server, I will not go into the details here. The short story is that the DNS contains many applications, each interacting with a part of a gigantic manual that translates hostnames to IP addresses. Client's communication with the DNS is how Client comes to know the IP address of SiteGround's Device, so you don't have to.

So let's suppose that Client and Server have met before (such that Client can translate "www.siteground.com" to the relevant IP address). Still, it wouldn't be a believable scene if they just started demanding stuff from one another. Let's assume they're not playing out a scene from a Hobbesian state of nature. They need to engage in some pre-communication handshaking first.

Client processes attempt to communicate with Server processes under the _Transmission Control Protocol_ (TCP) and the _Transport Layer Security_ (TLS) protocol. Because of this, some exchanges need to take place in preparation for the transfer of information of interest. Client and Server engage in a _TCP three-way handshake_ to warm up to one another (to _connect_). Then a _TLS handshake_ that _authenticates_ Server to Client and prepares Client and Server for _encrypted_ message passing takes place. The TCP handshake begins with Client sending a message from the _port_ it is running on to a listening Server (on _port 443_) with a humble request to _connect_ or _synchronize_. How does this message get to Server?

To send the request to synchronize to Server, Client provides the IP address of Server to Your Device and asks Your Device to submit the request along the internet highway. Your Device packages the request up and submits it to a _gateway_ via _Ethernet_ or _Wi-Fi_. A gateway is a server in that strange device behind your TV with the blinking lights. Let's call that extra player "Your Gateway". Cue Hitchcock cameo. Your Gateway sends the _packet_ across the internet---the packet hops from one _router_ to the next. Because the `IP address` is stamped on the packet, the packet eventually reaches the gateway ("SiteGround's Gateway") to the network of SiteGround's Device. SiteGround's Gateway encapsulates the packet into a _frame_. The frame contains information on the location of SiteGround's Device within its local network. The frame travels there via _Ethernet_ or _Wi-Fi_. Once the frame reaches SiteGround's Device, it is ripped open in a frenzy by SiteGround's Device and passed along to Server on _port 443_. Server strips off the final packaging to reveal the request to synchronize! How magical!

![The Ask](dev.jpeg)

Let's suppose all goes well. Maybe Server is delighted to serve Client. Maybe Client has something on Server, so Server can't help but do what Client 'asks'. Poor Server! Yeah, let's go with that one. It's dramatic. Whatever the details of this part of the plot, Server eventually responds with its message. This message essentially _acknowledges_ the request and agrees to synchronize. That message is packaged up and sent along that crazy internet highway back to Client. The second part of the three-way handshake is complete. Now for the finale. Client sends a final message that _acknowledges_ Server's willingness to synchronize. At this point, a _connection_ is established between Client and Server. There's a unique communication channel (or _socket_) that begins with the part of the internet highway identified by SiteGround Device's _IP address_ and ends at _port 443_ on SiteGround's Device. Client uses this socket to talk to Server, and Server uses it to listen to Client. There's also a unique _socket_ that begins with the part of the internet highway identified by Your Device's _IP address_ and ends with some _port_ on Your Device. Server uses this socket to talk to Client, and Client uses it to listen to Server. In this way, you can think of a socket identifier as an _IP address_-_port number_ pair.

![The Players](Notorious-ending.jpeg)

Perhaps we can imagine that Client and Server unwittingly begin to have feelings for one another. However, before our heroes smooch for _three whole minutes_, we need to thicken the plot a bit. Something needs to get in the way of this budding romance. It wouldn't be an engaging Hitchcockian spy thriller romance without a bit of confrontation! Perhaps another user on the internet seeks to gain unauthorized access to Server, seeks to compromise your privacy, or seeks to alter Client's messages to Server (or vice-versa). The hack is a notorious bad guy who seeks to strike fear in the hearts of users. Of course, love conquers all, and the bad guys always trip up somewhere. But let's not wait around for them to screw up. What shall Client and Server do to prevent the bad guy from messing with them?

Well, now that Client and Server have gotten to know each other through the three-way handshake, they do another handshake. This is the Transport Layer Security (TLS) handshake that I mentioned earlier. The TLS handshake will (a) establish trust between Client and Server and (b) create a _symmetric key_ for encrypting and decrypting the messages they send back and forth to one another.

Glue your eyes to the screen. Observe as Hitchcock closes in on Cary Grant and Ingrid Bergman's hands...err, I mean Client and Server's hands. Client sends Server a list of _cipher suites_ and the _highest TLS protocol version_ it is capable of supporting. Server decides on which _cipher suite_ and TLS protocol Client and Server should use, and Server sends Client information on the outcome of this decision along with a _certificate_ and a _public key_. Client checks out the _certificate_. Since it has Server's _signature_, Server must, indeed, be Server.

But, wait a minute! Maybe Server has pulled a fast one. Or maybe the bad guy is posing as Server. Anybody, including the bad guy, can send to Client something that looks like a certificate and includes (1) a public key, and (2) a signature. So, how does our Client trust Server?

It turns out that Server's certificate was also signed by AlphaSSL, an _intermediate Certificate Authority_ (CA). You can view SiteGround's certificate yourself by clicking the little lock in Client's address bar next to the _Uniform Resource Locator_ (URL). Because of this, Client has _reasons_ for trusting Server. What are they? Well, Client trusts GlobalSign, a _root CA_, and GlobalSign signs off on AlphaSSL's certificate. Since Client already trusts GlobalSign and GlobalSign has given AlphaSSL the stamp of approval, Client trusts AlphaSSL. Since Client trusts AlphaSSL, and AlphaSSL has given Server the stamp of approval, Client trusts Server. Trust is transitive.

You might wonder why Client trusts GlobalSign. Even if trust is transitive, the above reasoning does not get off the ground unless Client begins by trusting somebody! So, again, why trust GlobalSign? The answer is that trust must bottom out somewhere. This isn't a plot hole. As I said before, this is not a story about a Hobbesian state of nature! It's a Hitchcockian spy thriller romance that one might say is _all about trust_!

![The Key](key.jpeg)

So, Server's not working for the bad guy. Shame on you for thinking it was a turncoat! After Client gets over its trust issues, it continues with the TLS protocol handshake. In particular, Client uses Server's public key to encrypt and send a _pre-master secret key_. Server uses its _private key_ to decrypt the _pre-master secret key_. So, finally, both Client and Server have a copy of the _pre-master secret key_. At this point, both Client and Server generate copies of a _symmetric key_ from the _pre-master secret key_ using a relevant cipher. They will each use the _symmetric key_ to encrypt and decrypt messages sent back and forth. Those baddies don't stand a chance!

#### Act II

As you will undoubtedly remember, dear reader, our story began with you typing "https://www.siteground.com/" into your browser and hitting enter. As I said, a lot happens before Client sends a request to Server that has anything remotely to do with your intention of getting to SiteGrounds's homepage. But now we are ready for the main event.

Client crafts a HyperText Transfer Protocol (HTTP) `GET` request on your behalf. Such a request is a message composed of the HTTP request _Header_ and a (possibly blank) _Body_. The _Header_ includes a required _request line_, a required "`host`" _header_, and any other optional _headers_. Given that an empty line separates the HTTP request _Header_ and _Body_, Client minimally sends something like the following to Server:

```text
GET / HTTP/1.1
host: www.siteground.com
// Blank Line
// Blank Body
```

As you can see, Client is the strong silent type. Client is requesting that Server `GET` the desired _resource_ at the end of _path_ `/` using `HTTP` version `1.1`. The path string "`/`" indicates to Server that Client is requesting the _home_ resource or landing page of some _host_. What host? Well, the second line of the HTTP request from Client contains that information. This is the "`host`" _header_. It is the only _header_ that is required in an HTTP request's _Header_. All _headers_ have a "`header: value`" syntax. The third line is intentionally left blank. The third line serves as a separator between the HTTP request _Header_ and the HTTP request _Body_.

Next, according to the TLS protocol, Client _encapsulates_ the HTTP request into a TLS _record_. In particular, Client uses the _symmetric key_ to encrypt the HTTP request. The encrypted HTTP request becomes the _Body_ or _payload_ of the TLS record. The _Header_ of the TLS record contains data about its contents (_meta-data_), including the version of the TLS protocol being used. Client also decks the TLS _record_ out with a _Footer_, which contains a _Message Authentication Code_ or the value of the "`MAC`" _footer_. Remember when I told you to focus on what Server and Client were doing during the TLS handshake? Well, in case you missed something from Ted Tetzlaff's glorious close-up, Server decided what _cipher suite_ would be used, and one of the ciphers in that cipher suite must be a MAC function. The MAC function takes two arguments---the decrypted HTTP message and _the symmetric key_---and returns a MAC. If the MAC function is a good one, the return value will be distinct for any change _in either the HTTP message or the symmetric key_. The receiver of any TLS record may now check whether any baddies have tampered with the HTTP request. Even if the bad guy could change the HTTP message, he does not have access to _the symmetric key_. So, he would not _also_ be able to change the MAC appropriately. Hence, if the sent `MAC` is not identical to the MAC that the receiver derives, Client and Server would know something has gone awry. Did I mention that the baddies don't stand a chance yet?

![Encrypted Communication](Notorious_Trailer_-_At_the_Horseracing_track.jpeg)

Client has done everything by the TLS book. It is time for Client to dot all the "i"s and cross all the "t"s of the TCP. Client must do this before sending the (encapsulated) HTTP request along the internet highway to Server. Of course, it would make it a more exciting movie if Client or Server broke some protocols, but we're going to have our heroes play by the rules here.

Fundamentally, following the TCP makes it so this movie does not end with a _Mad Max_ chase scene on the rough internet highway. The TCP makes the _request/response cycle_ much more orderly and reliable than it would be without it. In any case, wouldn't it be a shame for our heroes not to communicate successfully and reliably after all the preparatory work I mentioned above? We might imagine the movie ending with a grandiose chase sequence, but it is not one that occurs in a post-apocalyptic wasteland thanks to the TCP. Okay, enough stage-setting. Let's get to the climax!

#### Act III

Client breaks up the TLS record into _segments_. Each TCP segment will be encapsulated as a separate IP _packet_ as it careens along the internet highway. So that things don't get lost in the fray, Client stamps each segment with a `sequence #` (that is, the value of the "`sequence #`" header). Given the `sequence #`, Server will reassemble the TLS record and ultimately the HTTP request. In other words, following the TCP allows for _in-order delivery_. Client also stamps a `checksum` onto each segment. This kind of works like the `MAC` that I discussed above; however, instead of ensuring message integrity, the `checksum` ensures the data hasn't been damaged. Finally, Client does not send each segment one at a time. To make the most use of the _bandwidth_ (number of lanes on the internet highway), Client _pipelines_ the _segments_. That is, Client sets a `window size` (say, 5) and sends that amount of segments at once.

Let's say there are just 10 segments in total. All 10 of them must make it to Server for communication to be successful. As was previously mentioned, the segments get wrapped up into an IP _packet_. Your Device stamps the relevant `IP address` and a `time to live` on it. If the segment doesn't make it to Server before its `time to live` runs out, it will explode! Well, actually, it will just be 'dropped'. But, in any case, time is ticking. Your Device sends each segment out with 4 other segments at once. There they go. The first 5 make it to Server without a hitch. Server strips off the IP packaging to reveal the `sequence #` and begins reassembly. For each segment that Server receives, it sends an _acknowledgment_ of receipt back to Client along with a corresponding `acknowledgment #` and Server's preferred `window size`. Let's say 5 is a-okay as far as Server is concerned. That is how following the TCP enables _flow control_.

![The Chase](notorious-drink-driving.jpeg)

Given the time (or overall _latency_) it takes Client to receive an acknowledgment, Client has some idea of internet highway congestion. If it took a long time to receive some acknowledgments, Client could hold off on sending the final 5 segments. That is, following the TCP enables _congestion avoidance_. But let's suppose that the time it takes Client to receive the first 4 acknowledgments is not too long. Client surmises that the internet must not be too congested. However, Client is still waiting for the fifth acknowledgment. What happened? Of course, Server did receive it, but Client does not know that. So, instead of sending the final 5, Client first attempts to send the fifth segment from the first batch _again_.

_As before_, the fifth segment of the first batch reaches Server. Server is puzzled. Oh no! This is not what was planned! Something has gone wrong! But not to worry, Server quickly realizes that Client must not have received its acknowledgment. Server throws the duplicated segment away, brushes the sweat from its brow, crossing its fingers, and sends the acknowledgment again. Following the TCP enables _de-duplication_.

Success! Client receives the fifth acknowledgment and immediately submits the final 5 segments. Your request to land on SiteGround's homepage is almost complete, dear reader! Client receives the first acknowledgment. Client receives the second acknowledgment. Client receives the third acknowledgment. A bead of sweat drips off of Client's dimpled chin. The suspense is killing me! Client receives the fourth acknowledgment. More time is passing in between receiving the acknowledgments. Is the internet becoming more congested, or has something gone wrong? Have the bad guys intercepted a segment? Was one of the segments drunk?

![Suspense](notorious-suspense.jpeg)

Client wonders whether it should submit the fifth segment of the final batch again---a close-up of Client's squinting eyes. Client mutters, "what is it dear, what's wrong?", in a mid-Atlantic accent. Just then, the fifth acknowledgment comes through! Client quickly sends a final empty segment indicating to Server that the request is _finished_. Soon after this, Client receives an acknowledgment that the request segments are finished. Hooray!

Server finishes reassembling the segments into a TLS record. Server checks the `MAC` against what its MAC function produces, and all is good. It is now time for Server to process the HTTP request and prepare the HTTP response. That's what you've been waiting for this entire split second! As with an HTTP request, the HTTP response contains a _Header_ and a _Body_. The _Header_ contains the _status line_ and _headers_. The _Body_ contains some HyperText Markup Language (HTML) of the page you are patiently waiting to see. Server sends something like the following to Client:

```text
HTTP/1.1 200 OK
date: Sat, 20 April 1946 19:20:52 GMT
content-type: text/html; charset=UTF-8
set-cookie: <cookie value>
set-cookie: <another cookie value>
// Blank Line
<Big HTML File>
```

Let's skip the first line (the _status line_) for a moment. Let's start from the bottom. The Big HTML File is what Client translates into what you actually see in Client's window. Above that, we have a blank line, and then we have the _headers_ before the _status line_. The "`set-cookie`" headers are of particular interest. An essential feature of the HTTP is that it requires neither Client nor Server to store anything about previous requests or responses. In this sense, the HTTP is _stateless_ or _memoryless_. However, that does not imply that Client and Server _cannot_ store some information about previous requests or responses. Indeed, you probably hope that they do. If neither Client nor Server stored anything from previous requests or responses, your browsing experience would be a choppy jumbled mess. You'd have the experience of being born into the world wide web with each and every click. There'd be no shopping carts and no saved Likes. So, Server will include a unique session token cookie that Server will associate with the previous state of your browsing experience when Server sends Client the HTTP response. The session token cookie is the value of one of the "`set-cookie`" headers. In future HTTP requests, Client will use that cookie to help Server find the correct state so that you don't have the sense of being re-born again and again. It will be included as the value of a "`cookie`" header in subsequent HTTP requests.

Finally, let's look at the _status line_. It contains the version of the HTTP being used, the status code, and the status text. Common code-text pairs include "`302 Found`", "`404 Not Found`", "`500 Internal Server Error`", and "`200 OK`". These mean different things.  The first one means that Server found the resource, but its _origin_ has changed (perhaps temporarily). The second one means that Server did not find the resource (which is because you've typed something wrong into the address bar of Client). The third one means that Server is having some issues of its own. Our story has the happiest of endings! The code-text pair "`200 OK`" means that Server handled the HTTP request successfully. Let the _three minutes of kissing_ commence!

![Smooches](notorious.jpeg)
